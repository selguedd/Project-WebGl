<!DOCTYPE html>
<html>

<head>
</head>

<body>
    <canvas id="webgl_canvas" style="background: url('../textures/univers.jpg')"></canvas>
  



    <script src="../gl-matrix-min.js"></script>
    <script language="javascript" type="text/javascript" src="../camera.js"></script>
    <script language="javascript" type="text/javascript" src="../shaders.js"></script>
    <script language="javascript" type="text/javascript" src="../textures.js"></script>
    <script language="javascript" type="text/javascript" src="objects_02.js"></script>
    <script>
        async function main() {
            // Boilerplate code
            const canvas = document.getElementById('webgl_canvas');
            //canvas.width = canvas.clientWidth;
            //canvas.height = canvas.clientHeight;
            const width  = window.innerWidth || document.documentElement.clientWidth || 
            document.body.clientWidth;
            const height = window.innerHeight|| document.documentElement.clientHeight|| 
            document.body.clientHeight;

            console.log(width, height);
            canvas.width = width-10;

            canvas.height = height-20;
            const gl = canvas.getContext('webgl');
            c_width = canvas.width;
            c_height =canvas.height;
            console.log(canvas.clientHeight); 
            console.log(canvas.clientWidth); 
            // Enable tests for better rendering
            gl.enable(gl.DEPTH_TEST);
            //gl.enable(gl.CULL_FACE); // cull hidden faces behind normals!

            const sourceV = `
      attribute vec3 position;
      attribute vec2 texcoord;
      attribute vec3 normal;
      varying vec2 v_texcoord;
      varying vec3 v_color;
      
      uniform mat4 M;
      uniform mat4 V;
      uniform mat4 P;

      void main() {
        gl_Position = P*V*M*vec4(position, 1);
        v_texcoord = texcoord;
        // We will display the normals as a color
        v_color = (normal+1.0)/2.0;
      }
    `;

            const sourceF = `
      precision mediump float;
      varying vec2 v_texcoord;
      //varying vec3 v_color;
      
      uniform sampler2D u_texture1;
      uniform sampler2D u_texture2;

      void main() {
        gl_FragColor = texture2D(u_texture1, vec2(v_texcoord.x, 1.0-v_texcoord.y));
        //gl_FragColor = vec4(normalize(v_color), 1.0);
      }
    `;

            var shader_show_object = make_shader(gl, sourceV, sourceF);
            
            // loading the object from a file
            var cube = await load_obj('../objects/sphere_smooth.obj');
            var plane = await load_obj('../objects/cube.obj');
            // Asynchronous call, we waited till the object was ready
            // Make the buffer and the functions to draw the object:
            var cube_mesh = await make_object(gl, cube);
            var plane_mesh = await make_object(gl, plane);

            position = glMatrix.vec3.fromValues(0, 0, -4.0)
            up = glMatrix.vec3.fromValues(0.0, 1.0, 0.0)
            yaw = -90.0
            pitch = 0.0
            var camera = make_camera(canvas, position, up, yaw, pitch)
            var projection = camera.get_projection(45.0, c_width / c_height, 0.01, 100.0)

            const camMatElem = document.querySelector("#camera_mat");
            const projMatElem = document.querySelector("#proj_mat");
             // Texture
            var texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            
            // Fill the texture with a 1x1 blue pixel.
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE,
                    new Uint8Array([0, 0, 255, 255]));
            var image = new Image();
            image.crossOrigin = "anonymous";
            image.src = "../textures/earthmap1k.jpg";
            image.addEventListener('load', function() {
              // Now that the image has loaded make copy it to the texture.
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA,gl.UNSIGNED_BYTE, image);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
              gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            });
            gl.bindTexture(gl.TEXTURE_2D, null);
            
            var deltaTime = 0;

           
            function animate(time) {
                deltaTime += 0.005;
                camera.update(deltaTime);
                //Draw loop
                gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

                shader_show_object.use();
                cube_mesh.activate(shader_show_object);

                var unif = shader_show_object.get_uniforms();

                view = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif['model'], false, cube_mesh.model);
                gl.uniformMatrix4fv(unif['view'], false, view);
                gl.uniformMatrix4fv(unif['proj'], false, projection);

                cube_mesh.draw();
                
                
                plane_mesh.activate(shader_show_object);

                var unif = shader_show_object.get_uniforms();

                view = camera.get_view_matrix();
                gl.uniformMatrix4fv(unif['model'], false, plane_mesh.model);

                plane_mesh.draw();
                
                


                gl.bindTexture(gl.TEXTURE_2D, texture);
                fps(time);
                window.requestAnimationFrame(animate); // While(True) loop!
            }

            var prev = 0
            const fpsElem = document.querySelector("#fps");

            function fps(now) {
                now *= 0.001;
                const deltaTime = now - prev;
                prev = now;
                const fps = 1 / deltaTime;
                return fps;
            }

            animate(0);
        }

        main();
    </script>
</body>

</html>